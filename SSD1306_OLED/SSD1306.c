/*
 * SSD1306.c
 *
 *  Created on: Feb 3, 2020
 *      Author: ajose
 */
#include "SSD1306.h"

//#define INVERT_DISP
#define OLED_CMD     0x00
#define OLED_DATA    0x40

SSD1306_I2c_Inst_t oled_inst = {0};
SSD1306_TypeModeCtx_t typemode_ctx = {0};
uint8_t cmdBuf[8];

#define FONT_WIDTH       8
#define FONT_HEIGHT      8
const uint8_t font[96][9] = {
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, // [space]
    {0x00,0x5f,0x00,0x00,0x00,0x00,0x00,0x00}, // !
    {0x00,0x03,0x00,0x03,0x00,0x00,0x00,0x00}, // "
    {0x0a,0x1f,0x0a,0x1f,0x0a,0x00,0x00,0x00}, // #
    {0x24,0x2a,0x2a,0x7f,0x2a,0x2a,0x12,0x00}, // $
    {0x00,0x47,0x25,0x17,0x08,0x74,0x52,0x71}, // %
    {0x00,0x36,0x49,0x49,0x49,0x41,0x41,0x38}, // &
    {0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00}, // '
    {0x00,0x3e,0x41,0x00,0x00,0x00,0x00,0x00}, // (
    {0x41,0x3e,0x00,0x00,0x00,0x00,0x00,0x00}, // )
    {0x04,0x15,0x0e,0x15,0x04,0x00,0x00,0x00}, // *
    {0x08,0x08,0x3e,0x08,0x08,0x00,0x00,0x00}, // +
    {0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00}, // ,
    {0x08,0x08,0x08,0x08,0x08,0x00,0x00,0x00}, // -
    {0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00}, // .
    {0x40,0x20,0x10,0x08,0x04,0x02,0x01,0x00}, // /
    {0x00,0x3e,0x61,0x51,0x49,0x45,0x43,0x3e}, // 0
    {0x01,0x01,0x7e,0x00,0x00,0x00,0x00,0x00}, // 1
    {0x00,0x71,0x49,0x49,0x49,0x49,0x49,0x46}, // 2
    {0x41,0x49,0x49,0x49,0x49,0x49,0x36,0x00}, // 3
    {0x00,0x0f,0x10,0x10,0x10,0x10,0x10,0x7f}, // 4
    {0x00,0x4f,0x49,0x49,0x49,0x49,0x49,0x31}, // 5
    {0x00,0x3e,0x49,0x49,0x49,0x49,0x49,0x30}, // 6
    {0x01,0x01,0x01,0x01,0x01,0x01,0x7e,0x00}, // 7
    {0x00,0x36,0x49,0x49,0x49,0x49,0x49,0x36}, // 8
    {0x00,0x06,0x49,0x49,0x49,0x49,0x49,0x3e}, // 9
    {0x00,0x00,0x00,0x22,0x00,0x00,0x00,0x00}, // :
    {0x40,0x34,0x00,0x00,0x00,0x00,0x00,0x00}, // ;
    {0x08,0x14,0x22,0x00,0x00,0x00,0x00,0x00}, // <
    {0x14,0x14,0x14,0x14,0x14,0x00,0x00,0x00}, // =
    {0x22,0x14,0x08,0x00,0x00,0x00,0x00,0x00}, // >
    {0x00,0x06,0x01,0x01,0x59,0x09,0x09,0x06}, // ?
    {0x00,0x3e,0x41,0x5d,0x55,0x5d,0x51,0x5e}, // @
    {0x00,0x7e,0x01,0x09,0x09,0x09,0x09,0x7e}, // A
    {0x00,0x7f,0x41,0x49,0x49,0x49,0x49,0x36}, // B
    {0x00,0x3e,0x41,0x41,0x41,0x41,0x41,0x22}, // C
    {0x00,0x7f,0x41,0x41,0x41,0x41,0x41,0x3e}, // D
    {0x00,0x3e,0x49,0x49,0x49,0x49,0x49,0x41}, // E
    {0x00,0x7e,0x09,0x09,0x09,0x09,0x09,0x01}, // F
    {0x00,0x3e,0x41,0x49,0x49,0x49,0x49,0x79}, // G
    {0x00,0x7f,0x08,0x08,0x08,0x08,0x08,0x7f}, // H
    {0x00,0x00,0x00,0x00,0x7F,0x00,0x00,0x00}, // I
    {0x00,0x38,0x40,0x40,0x41,0x41,0x41,0x3f}, // J
    {0x00,0x7f,0x08,0x08,0x08,0x0c,0x0a,0x71}, // K
    {0x00,0x3f,0x40,0x40,0x40,0x40,0x40,0x40}, // L
    {0x00,0x7e,0x01,0x01,0x7e,0x01,0x01,0x7e}, // M
    {0x00,0x7e,0x01,0x01,0x3e,0x40,0x40,0x3f}, // N
    {0x00,0x3e,0x41,0x41,0x41,0x41,0x41,0x3e}, // O
    {0x00,0x7e,0x09,0x09,0x09,0x09,0x09,0x06}, // P
    {0x00,0x3e,0x41,0x41,0x71,0x51,0x51,0x7e}, // Q
    {0x00,0x7e,0x01,0x31,0x49,0x49,0x49,0x46}, // R
    {0x00,0x46,0x49,0x49,0x49,0x49,0x49,0x31}, // S
    {0x01,0x01,0x01,0x7f,0x01,0x01,0x01,0x00}, // T
    {0x00,0x3f,0x40,0x40,0x40,0x40,0x40,0x3f}, // U
    {0x00,0x0f,0x10,0x20,0x40,0x20,0x10,0x0f}, // V
    {0x00,0x3f,0x40,0x40,0x3f,0x40,0x40,0x3f}, // W
    {0x00,0x63,0x14,0x08,0x08,0x08,0x14,0x63}, // X
    {0x00,0x07,0x08,0x08,0x78,0x08,0x08,0x07}, // Y
    {0x00,0x71,0x49,0x49,0x49,0x49,0x49,0x47}, // Z
    {0x00,0x7f,0x41,0x00,0x00,0x00,0x00,0x00}, // [
    {0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x00}, // "\"
    {0x41,0x7f,0x00,0x00,0x00,0x00,0x00,0x00}, // ]
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, // ^
    {0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x00}, // _
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, // `
    {0x00,0x7e,0x01,0x09,0x09,0x09,0x09,0x7e}, // A
    {0x00,0x7f,0x41,0x49,0x49,0x49,0x49,0x36}, // B
    {0x00,0x3e,0x41,0x41,0x41,0x41,0x41,0x22}, // C
    {0x00,0x7f,0x41,0x41,0x41,0x41,0x41,0x3e}, // D
    {0x00,0x3e,0x49,0x49,0x49,0x49,0x49,0x41}, // E
    {0x00,0x7e,0x09,0x09,0x09,0x09,0x09,0x01}, // F
    {0x00,0x3e,0x41,0x49,0x49,0x49,0x49,0x79}, // G
    {0x00,0x7f,0x08,0x08,0x08,0x08,0x08,0x7f}, // H
    {0x00,0x00,0x00,0x00,0x7F,0x00,0x00,0x00}, // I
    {0x00,0x38,0x40,0x40,0x41,0x41,0x41,0x3f}, // J
    {0x00,0x7f,0x08,0x08,0x08,0x0c,0x0a,0x71}, // K
    {0x00,0x3f,0x40,0x40,0x40,0x40,0x40,0x40}, // L
    {0x00,0x7e,0x01,0x01,0x7e,0x01,0x01,0x7e}, // M
    {0x00,0x7e,0x01,0x01,0x3e,0x40,0x40,0x3f}, // N
    {0x00,0x3e,0x41,0x41,0x41,0x41,0x41,0x3e}, // O
    {0x00,0x7e,0x09,0x09,0x09,0x09,0x09,0x06}, // P
    {0x00,0x3e,0x41,0x41,0x71,0x51,0x51,0x7e}, // Q
    {0x00,0x7e,0x01,0x31,0x49,0x49,0x49,0x46}, // R
    {0x00,0x46,0x49,0x49,0x49,0x49,0x49,0x31}, // S
    {0x01,0x01,0x01,0x7f,0x01,0x01,0x01,0x00}, // T
    {0x00,0x3f,0x40,0x40,0x40,0x40,0x40,0x3f}, // U
    {0x00,0x0f,0x10,0x20,0x40,0x20,0x10,0x0f}, // V
    {0x00,0x3f,0x40,0x40,0x3f,0x40,0x40,0x3f}, // W
    {0x00,0x63,0x14,0x08,0x08,0x08,0x14,0x63}, // X
    {0x00,0x07,0x08,0x08,0x78,0x08,0x08,0x07}, // Y
    {0x00,0x71,0x49,0x49,0x49,0x49,0x49,0x47}, // Z
    {0x08,0x36,0x41,0x00,0x00,0x00,0x00,0x00}, // {
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, // |
    {0x41,0x36,0x08,0x00,0x00,0x00,0x00,0x00}, // }
    {0x02,0x01,0x01,0x02,0x02,0x01,0x00,0x00}, // ~
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}
};

void SSD1306_Write_Cmd(uint8_t cmd)
{
    cmdBuf[0] = OLED_CMD;  //command
    cmdBuf[1] = cmd;
    oled_inst.i2c_write_ptr(oled_inst.sAddr, cmdBuf, 2);
}

void SSD1306_Write_Cmd2(uint8_t cmd1, uint8_t cmd2)
{
    cmdBuf[0] = OLED_CMD;  //command
    cmdBuf[1] = cmd1;
    cmdBuf[2] = cmd2;
    oled_inst.i2c_write_ptr(oled_inst.sAddr, cmdBuf, 3);
}

void SSD1306_Write_Cmd3(uint8_t cmd1, uint8_t cmd2, uint8_t cmd3)
{
    cmdBuf[0] = OLED_CMD;  //command
    cmdBuf[1] = cmd1;
    cmdBuf[3] = cmd2;
    cmdBuf[3] = cmd3;
    oled_inst.i2c_write_ptr(oled_inst.sAddr, cmdBuf, 4);
}

void SSD1306_Write_Data(uint8_t *pData, uint16_t len)
{
    //For this to work, first byte sent must be 0x40 to indicate data write to OLED
    oled_inst.i2c_write_ptr(oled_inst.sAddr, pData, len);
}

void SSD1306_ClearBackBuffer()
{
    memset(&oled_inst.pBackBuf[1], 0, SSD1306_64x128_BUFSIZE - 1);
}

void SSD1306_UpdateScreen()
{
    SSD1306_SwapVramBufs();   //Swap the back buffer (which all draw functions render to) to the front
    SSD1306_Write_Data(oled_inst.pFrontBuf, SSD1306_64x128_BUFSIZE);   //Write out the front VRAM buffer to the display
    SSD1306_ClearBackBuffer();
}

uint16_t GetBufIndexFromCoords(uint8_t x, uint8_t y)
{
    uint16_t x_shrt = (uint16_t)(x);
    uint16_t y_shrt = (uint16_t)(y);
    uint16_t page = (y_shrt / 8); //Integer division rounds down, get page we are on (pages are 8 rows tall)
    return (1 + x_shrt + (page * 128));  //Add 1 as first index of the buffer is the data cmd code
}

uint8_t GetBitPositionFromY(uint8_t y)
{
    return (y % 8);
}

void SSD1306_SetPixel(uint8_t x, uint8_t y)
{
    if(x < 128 && y < 64)
    {
        if(oled_inst.pBackBuf)
            oled_inst.pBackBuf[GetBufIndexFromCoords(x, y)] |= (1 << GetBitPositionFromY(y));
    }
}

void SSD1306_ClearPixel(uint8_t x, uint8_t y)
{
    if(x < 128 && y < 64)
    {
        if(oled_inst.pBackBuf)
            oled_inst.pBackBuf[GetBufIndexFromCoords(x, y)] &= ~(1 << GetBitPositionFromY(y));
    }
}

void SSD1306_TogglePixel(uint8_t x, uint8_t y)
{
    if(x < 128 && y < 64)
    {
        if(oled_inst.pBackBuf)
            oled_inst.pBackBuf[GetBufIndexFromCoords(x, y)] ^= (1 << GetBitPositionFromY(y));
    }
}

void SSD1306_SetBackBufByte(uint16_t bufIdx, uint8_t byte)
{
    if((bufIdx) && (bufIdx < SSD1306_64x128_BUFSIZE))
    {
        oled_inst.pBackBuf[bufIdx] = byte;
    }
}

void SSD1306_DrawLine(int x0, int y0, int x1, int y1)
{
    int steep = abs(y1 - y0) > abs(x1 - x0);
    if (steep)
    {
        int tmp = x0;
        x0 = y0;
        y0 = tmp;

        tmp = x1;
        x1 = y1;
        y1 = tmp;
    }

    if (x0 > x1)
    {
        int tmp = x0;
        x0 = x1;
        x1 = tmp;

        tmp = y0;
        y0 = y1;
        y1 = tmp;
    }

    int dx, dy;
    dx = x1 - x0;
    dy = abs(y1 - y0);

    int err = dx / 2;
    int ystep;

    if (y0 < y1)
      ystep = 1;
    else
      ystep = -1;

    for (; x0 <= x1; x0++)
    {
        if(steep)
            SSD1306_SetPixel(y0, x0);
        else
            SSD1306_SetPixel(x0, y0);

        err -= dy;
        if (err < 0)
        {
          y0 += ystep;
          err += dx;
        }
    }
}

void SSD1306_DrawRectangle(uint8_t x_origin, uint8_t y_origin, uint8_t width, uint8_t height)
{
    SSD1306_DrawLine(x_origin, y_origin, x_origin + width, y_origin);
    SSD1306_DrawLine(x_origin, y_origin, x_origin, y_origin + height);
    SSD1306_DrawLine(x_origin, y_origin + height, x_origin + width, y_origin + height);
    SSD1306_DrawLine(x_origin + width, y_origin, x_origin + width, y_origin + height);
}

void SSD1306_DrawFilledRectangle(uint8_t x_origin, uint8_t y_origin, uint8_t width, uint8_t height)
{
    for(uint8_t i = 0; i < width; i++)
    {
        SSD1306_DrawLine(x_origin, y_origin, x_origin, y_origin + height);
        x_origin++;
    }
}

void SSD1306_DrawAsciiChar(uint8_t c, uint8_t pos_x, uint8_t pos_y)
{
    if(c >= ' ' && c <= '~')  //An ASCII character
    {
        for(uint8_t x = 0; x < FONT_WIDTH; x++)
        {
            for(uint8_t y = 0; y < FONT_HEIGHT; y++)
            {
                if(font[c - 0x20][x] & (1<<y))
                    SSD1306_SetPixel(pos_x + x, pos_y + y);
            }
        }
    }
}

void SSD1306_TypeModeSetCursor(uint8_t pos_x, uint8_t pos_y)
{
    if(pos_x < 16 && pos_y < 8)
    {
        typemode_ctx.cursorPosInArray = pos_x + 16*pos_y;
    }
}

void SSD1306_TypeModeTypeCh(uint8_t c)
{
    if(c >= ' ' && c <= '~')
    {
        typemode_ctx.characterMemory[typemode_ctx.cursorPosInArray] = c;
        typemode_ctx.cursorPosInArray++;
        if(typemode_ctx.cursorPosInArray >= 128)
        {
            typemode_ctx.cursorPosInArray = 0;
        }
    }
    else if(c == '\b')  //Backspace
    {
        if(typemode_ctx.cursorPosInArray != 0)
        {
            typemode_ctx.characterMemory[typemode_ctx.cursorPosInArray - 1] = ' ';
            typemode_ctx.cursorPosInArray--;
        }
        else  //Wrap around, probably don't want to do this.
        {
            //typemode_ctx.characterMemory[NUM_CHARS_ONDISPLAY_MAX - 1] = ' ';
            //typemode_ctx.cursorPosInArray = NUM_CHARS_ONDISPLAY_MAX - 1;
        }
    }
    else if(c == '\r')
    {
        typemode_ctx.cursorPosInArray /= 16;     //Integer division will yield integers 0-7, determining the row it's in.
        typemode_ctx.cursorPosInArray *= 16;     //Multiply by number of character columns to put it in array position at beginning of a row
    }
    else if(c == '\n')
    {
        if(typemode_ctx.cursorPosInArray < 112)   //Not in the last row (row 7)
        {
            typemode_ctx.cursorPosInArray += 16;
        }
        else     //In last row (row 7)
            typemode_ctx.cursorPosInArray = 16 - (NUM_CHARS_ONDISPLAY_MAX - typemode_ctx.cursorPosInArray);
    }
    else{}

    for(uint8_t i = 0; i < NUM_CHARS_ONDISPLAY_MAX; i++)
    {
        SSD1306_DrawAsciiChar(typemode_ctx.characterMemory[i], (i % 16)*FONT_WIDTH, (i / 16)*FONT_HEIGHT);
    }
}

char oledPrintBuf[NUM_CHARS_ONDISPLAY_MAX + 1] = {0};
void SSD1306_Printf(const char *format, ...)
{
    va_list va;
    va_start(va, format);
    vsnprintf(oledPrintBuf, NUM_CHARS_ONDISPLAY_MAX + 1, format, va);
    va_end(va);
    for(uint8_t i = 0; i < strlen(oledPrintBuf); i++)
    {
        SSD1306_TypeModeTypeCh(oledPrintBuf[i]);
    }
}

void SSD1306_SwapVramBufs()
{
    if(oled_inst.pFrontBuf && oled_inst.pBackBuf)
    {
        uint8_t *pTmp = oled_inst.pFrontBuf;
        oled_inst.pFrontBuf = oled_inst.pBackBuf;
        oled_inst.pBackBuf = pTmp;
    }
}

int SSD1306_Oled_Init(uint8_t sAddr, void (*i2c_wr_ptr)(uint8_t sAddr, uint8_t *pData, uint16_t len))
{
    //Default to primary slave address if user-provided address does not match one of possible SSD1306 SADDR
    if(sAddr != SSD1306_SADDR1 && sAddr != SSD1306_SADDR2)
        oled_inst.sAddr = SSD1306_SADDR1;
    else
        oled_inst.sAddr = sAddr;

    //Set instance I2C write function pointer provided by user
    if(!i2c_wr_ptr)
        return -1;
    else
        oled_inst.i2c_write_ptr = i2c_wr_ptr;

    //Zero out both display buffers
    for(int i = 0; i < SSD1306_64x128_BUFSIZE; i++)
    {
        oled_inst.dispBufs[0][i] = 0;
        oled_inst.dispBufs[1][i] = 0;
    }
    oled_inst.dispBufs[0][0] = OLED_DATA;  //First byte sent, indicates display data to OLED
    oled_inst.dispBufs[1][0] = OLED_DATA;  //First byte sent, indicates display data to OLED
    oled_inst.pFrontBuf = oled_inst.dispBufs[0];
    oled_inst.pBackBuf = oled_inst.dispBufs[1];

    SSD1306_Write_Cmd(DISP_OFF);
    SSD1306_Write_Cmd2(SET_MULTIPLEX_RATIO, 0x3F);
    SSD1306_Write_Cmd2(SET_DISPLAY_OFFSET, 0x00);
    SSD1306_Write_Cmd(SET_DISPLAY_START_LINE);
    SSD1306_Write_Cmd(SET_SEG_REMAP);
    SSD1306_Write_Cmd(SET_COM_DIR_REMAP);
    SSD1306_Write_Cmd2(SET_COM_HWCFG, 0x12);
    SSD1306_Write_Cmd2(SET_CONTRAST, 0xFF);
#ifdef INVERT_DISP
    SSD1306_Write_Cmd(SET_INVERSE_DISP);
#else
    SSD1306_Write_Cmd(SET_NORMAL_DISP);
#endif
    SSD1306_Write_Cmd2(CHARGE_PUMP_SETTING, CHARGE_PUMP_ON);
    SSD1306_Write_Cmd(DISP_ON);
    SSD1306_Write_Cmd2(SET_MEMADDR_MODE, MEMADDR_MODE_HORIZONTAL);

    SSD1306_Write_Cmd3(SET_COL_ADDR, 0, 127);
    SSD1306_Write_Cmd3(SET_PAGE_ADDR, 0, 7);

    SSD1306_UpdateScreen();

    SSD1306_Write_Cmd(DISP_ON);

    return 0;
}
